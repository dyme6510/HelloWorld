

;;
;;  PROBLEM: in der Idle-Sequence im Upper Border können Bad Lines auftreten
;;  Sowohl LineCrunch als auch LineDelay enden immer auf der letzten Line VOR der Bad Line
;;  also immer VOR setY
;;  -> danach einmal Sprite+Badline, vielleicht einmal Sprite ohne BadLine, vielleicht nochmal mit Bad Line
;; und dann auf jeden Fall IRQ
;; Timing schwierig bei Spritelücke 1,6









; Scroller links: alle 4 Lines ein neues Sprite. Benutzt Sprites 1-6


.pUpperBorderFade:
;       !byte %#######. ; line 39 schon per dec in RasterDoubleIRQ
        !byte %#.###.## ; line 40
        !byte %###.###. ; line 41
        !byte %.#.#.#.# ; line 42
        !byte %#.#.#.#. ; line 43
        !byte %.#...#.. ; line 44
        !byte %...#...# ; line 45
        !byte %.....#.. ; line 46
        !byte %........ ; line 47
.pLowerBorderFade:
        !byte %.....#..
        !byte %...#...#
        !byte %#.#.#.#.
        !byte %.###.###
        !byte %#######.
        !byte %########
!if (>* != >.pUpperBorderFade){
    !error "Borderfade on 1 page"
}
.cCountUpperBorderFadeLines = .pLowerBorderFade - .pUpperBorderFade

        
.cVic3FFF = cVicBank1Base + $3FFF


;; Zeropage                     
zpIrqRestoreA = $10
zpIrqRestoreX = $11
zpIrqRestoreY = $12

.zpFirstVisibleSpriteIndex = $13
.zpFirstVisibleSpriteOffset = $14
zpNextSpriteDataOffset = $15 ; Offset for pSpriteX, pSpriteData
zpNextSpriteIndex = $16  ; Next Sprite Index (0:1 ... 5:6)
.zpUnused           = $17
DoBorderStuffStep = $18 ;/$19
zpBorderFinish = $1A     
zpNextSpecialSpriteOffset = $1B
zpCurrentGfxScrollOffset = $1C ; 0-47
zpCurrentSpriteScrollOffset = $1D ; 0-23
.zpSpriteSequenceRestoreStack = $1E
.zpNextUpperControlV = $1F

.pNextSpriteEnterLo: !byte 0, <.NextSpriteDirect1, <.NextSpriteDirect2, <.NextSpriteDirect3, <.NextSpriteDirect4, <.NextSpriteDirect5, <.NextSpriteDirect6 ,0
.pNextSpriteEnterHi: !byte 0, >.NextSpriteDirect1, >.NextSpriteDirect2, >.NextSpriteDirect3, >.NextSpriteDirect4, >.NextSpriteDirect5, >.NextSpriteDirect6 ,0
.pSpecialSpriteNextOff: !byte 58,58,35,28,21 ; ScreenEnd, LineCrunchSpritePtr, Logo4, Logo3, Logo2, Logo1
.pSpecialSpriteNextCmd: !byte -1,-1, 1, 2, 3
.cLastSpriteIrqOffset = 58

.vUpperBorderDelayLines: !byte 0

            ; Scrolloffset    0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
.pGfxOffsetDelayLines: !byte 12,11,10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0, 6, 5, 4, 3, 2, 1, 0
.pGfxOffsetCrunchLines: !byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5
.pOffsetSpritePtrLine:  !byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,55,55,55,55,54,54,54,54,53,53,53,53,52,52,52,52,51,51,51,51,50,50,50,50,49,49,49,49,48,48,48,48,47,47,47
.cFirstGfxLine = $30 + 12


.pNextLogoData0: !byte (cGfxDymeLogoOffset>>6)+6,(cGfxDymeLogoOffset>>6)+4,(cGfxDymeLogoOffset>>6)+2,(cGfxDymeLogoOffset>>6)
.pNextLogoData7: !byte (cGfxDymeLogoOffset>>6)+7,(cGfxDymeLogoOffset>>6)+5,(cGfxDymeLogoOffset>>6)+3,(cGfxDymeLogoOffset>>6)+1
.pNextLogoY: !byte 158,130,102,74
.pNextLogoColor: !byte 1,1,1,1


.cLastVicLineForContinueWithSpriteIrq = $F2
.cFirstLowerBorderLine = $F8
.cVicLowerBorderFadeRamPtr = $80
.cVicBorderFadeVicBank = $C4 + $2
.cOpenBorderLine = $FA
.pVicBorderTextPage = $8000 + ((.cVicLowerBorderFadeRamPtr >> 4) * 1024)
.cEmptySpriteData = 0

.cRasterFirstIRQY = $30 - (.cCountUpperBorderFadeLines + 3)
.cInitialSprite0Y = .cRasterFirstIRQY-21+2
.cInitialSprite7Y = .cRasterFirstIRQY-21+1


!macro RtsOnStack .Addr{
    lda #>(.Addr-1)
    pha
    lda #<(.Addr-1)
    pha
}

;
; Erster Interrupt im neuen Frame: Zeile $26 (hier gibts noch keine Bad Lines)
;
; Vic-Status:
; Vic-Bank 01 ($8000-$C000).
; .cVic3FFF ist $FF
; Sprites 0,7 sind immer OFF, dadurch sind in jeder Rasterzeile 48-50 Takte Zeit. Bis Rasterzeile $27 müssen sie aber AN sein, wg. timing des DoubleIRQ
;   GENAUER: Sprite0 muss noch $28 AN sein, Sprite7 nicht mehr.
; der letze Write MUSS ein read-modify-write-Kommando @59 sein, dann sind es konstant 50 Takte

;; ########################################
;; ##     UPPER BORDER IRQ
;; ########################################

.RasterFirstIRQ:        ; Innerhalb der neuen Rasterline sind bereits 18-25 Takte vergangen.
                        ; ACHTUNG: nur Rasterlines 1-6, keine bad lines hier oder in der nächsten Zeile!

    inc vic_line        ; 6 Trigger DoubleIRQ on next Raster line
    sta zpIrqRestoreA   ; 3
    stx zpIrqRestoreX   ; 3 
    sty zpIrqRestoreY   ; 3 _15  @33-40

    lda #<.RasterDoubleIRQ  ; 2
    sta cpu_irq             ; 4
    asl vic_irq ; Ack IRQ   : 6     ; @43-52

    tsx                     ; 2     Store current Stack Pointer
    cli                     ; 2     Allow IRQ to happen (not tested with > 6-cycle commands before RasterFirstIRQ)
                                    ; @47-56 -> hier kann bereits das sprite-lock beginnen

    ; Execute NOPs until the raster line changes and the Raster IRQ triggers
    nop : nop : nop : nop : nop : nop     ; last nop needeed for 65cycle NTSC-VIC : T66-73
    
.RasterDoubleIRQ:   ; Innerhalb der neuen Rasterline sind bereits 18-19 Takte vergangen. (11 Nach Sprites, 7-8 für IRQ)
!if (>.RasterFirstIRQ != >.RasterDoubleIRQ){
    !error "KeepRasterIRQ on same Page: ", .RasterFirstIRQ, " - ", .RasterDoubleIRQ
}
    txs                                 ; 2         20-21    Restore Stack Pointer
    lda #<.DoUpperBorderFade            ; 2
    sta DoBorderStuffStep               ; 3
    lda #>.DoUpperBorderFade            ; 2
    sta DoBorderStuffStep+1             ; 3         ;_10
    
    +RtsOnStack .ReturnFromUpperBorderIrq ;10
    tsx                                 ; 2
    stx .zpSpriteSequenceRestoreStack   ; 3        
    ldy+2 zpNextSpriteIndex             ; 4         ;_19        49-50    
    
    ; AUFPASSEN! wir haben hier 8 Sprites! Der letzte Read is @54, Write geht noch 55,56
    ; den letzten cycle können wir also durch dec vor sprite#1 ausgleichen
+   dec .cVic3FFF                                   ; 6         56/57   writes @54/55 oder 55/56

    ; sprite#7 ist hier nicht mehr an: return @9    
    ldx .pSpriteSequenceStackPos,y                  ; 4
    txs                                             ; 2
    ldy+2 zpNextSpriteDataOffset                    ; 4
    rts                                             ; 6 _16 -> @25

; Die SpriteSequence hört immer in Zeile#4 eines Sprites auf, wir machen gleich mit dem nächsten Interrupt-Handler weiter
.ReturnFromUpperBorderIrq:  ;   @40
    sty zpNextSpriteDataOffset      ; 3
    ldx zpNextSpriteIndex           ; 3
    lda .pNextSpriteEnterLo,x       ; 2
    sta .vNextSpriteEnterAddr       ; 4
    lda .pNextSpriteEnterHi,x       ; 2
    sta .vNextSpriteEnterAddr+1     ; 4
    ldy zpIrqRestoreY               ; 3
.vNextSpriteEnterAddr = *+1    
    jmp .NextSpriteDirect1          ; 3 @65/@19
    
    

; jsr->bra->rts kostet 15 takte
; man kann sich auch die Aufrufe vorher auf den Stack tun, mit ldx #stackframe, txs den stack setzen und 
; dann nur noch jmp ($indirect) -> rts nutzen, das kostet nur 11 takte (und hat keine einschränkungen bzgl pages)
;               50 per Line (48 + 2rmw)
; jmp/rts  -11  39    
; modify jmp -5 32 (zeropage possible!)


;
;   Jeder Schritt für die Sprites braucht 17 takte incl. jmp(ind)
;   -> 33 takte für DoBorderStuff+rts
    
!macro BorderSpriteSequence .I{
.IPrev = ((.I+4) % 6)+1
.INext = (.I % 6)+1

    lda vic_ys0 + (.IPrev*2)                        ; 4     3b
    clc                                             ; 2     1b
    adc #4                                          ; 2     2b
    sta vic_ys0 + (.I*2)                            ; 4     3b
    jmp (DoBorderStuffStep)                         ; 5     3b ->+17 / 12b
    
    lda pSpriteX,y                                  ; 4     3b
    sta vic_xs0 + (.I*2)                            ; 4     3b
    ldx pSpriteColor,y                              ; 4     3b
    jmp (DoBorderStuffStep)                         ; 5     3b ->+17  / 12b
    
    lda pSpriteData,y                               ; 4     3b
    sta 1016+.I                                     ; 4     3b      Hi: __26b
    stx vic_cs0+.I                                  ; 4     3b      Hi: __26b
    jmp (DoBorderStuffStep)                         ; 5     3b ->+17  / 12b
    
    iny                                             ; 2     1b
    ldx zpBorderFinish                              ; 3     2b
    beq +                                           ; 2/3   2b
    lda #.INext                                     ; 2     2b
    sta zpNextSpriteIndex                           ; 3     2b
    jmp EndBorderSpriteSequence                     ; 3     3b ->+15 (@40)          / 12b 
+
!if (.INext = 1)  {  
    txs                                             ; 2     1b Stack wieder auf 0
} else {
    nop                                             ; 2     1b
}
    nop                                             ; 2     1b
    jmp (DoBorderStuffStep)                         ; 5     3b ->+17                / 17b
}


.cSpriteDataSequenceBlock1Len = 12;
.cSpriteDataSequenceBlock2Len = 12;
.cSpriteDataSequenceBlock2Off = .cSpriteDataSequenceBlock1Len;
.cSpriteDataSequenceBlock3Len = 12;
.cSpriteDataSequenceBlock3Off = .cSpriteDataSequenceBlock2Off + .cSpriteDataSequenceBlock2Len;
.cSpriteDataSequenceBlock4Len = 17;
.cSpriteDataSequenceBlock4Off = .cSpriteDataSequenceBlock3Off + .cSpriteDataSequenceBlock3Len;
    
; BorderSpriteSequence:
.BorderSpriteSequenceStart1:
    +BorderSpriteSequence 1
.BorderSpriteSequenceStart2:
    +BorderSpriteSequence 2
.BorderSpriteSequenceStart3:
    +BorderSpriteSequence 3
.BorderSpriteSequenceStart4:
    +BorderSpriteSequence 4
.BorderSpriteSequenceStart5:
    +BorderSpriteSequence 5
.BorderSpriteSequenceStart6:
    +BorderSpriteSequence 6

.BorderSpriteSequenceDelay1: ; @25
    ldy zpNextSpriteIndex                           ; 3
    ldx .pSpriteSequenceStackPos,y                  ; 4
    txs                                             ; 2
    ldy zpNextSpriteDataOffset                      ; 3
    jmp (DoBorderStuffStep)                         ; 5  ->+17
.BorderSpriteSequenceDelayN: ; @25
    inc .zpUnused                                   ; 5
    inc .zpUnused                                   ; 5
    jmp (DoBorderStuffStep)                         ; 5  ->+17    
    
    
.cBorderSpriteSequenceSpriteDataHi = .cSpriteDataSequenceBlock3Off + 5
.pSpriteDataHi_1 = .BorderSpriteSequenceStart1 + .cBorderSpriteSequenceSpriteDataHi
.pSpriteDataHi_2 = .BorderSpriteSequenceStart2 + .cBorderSpriteSequenceSpriteDataHi
.pSpriteDataHi_3 = .BorderSpriteSequenceStart3 + .cBorderSpriteSequenceSpriteDataHi
.pSpriteDataHi_4 = .BorderSpriteSequenceStart4 + .cBorderSpriteSequenceSpriteDataHi
.pSpriteDataHi_5 = .BorderSpriteSequenceStart5 + .cBorderSpriteSequenceSpriteDataHi
.pSpriteDataHi_6 = .BorderSpriteSequenceStart6 + .cBorderSpriteSequenceSpriteDataHi
    
    
.cSpriteDataSequenceBlockCount = (6*4)
.pSpriteSequenceStackPos: !byte -1, 0, 8, 16, 24, 32, 40, -1
.pSpriteSequenceStackPos2: !byte -1, 2, 10, 18, 26, 34, 42, -1

.pSpriteOffsetStartStackPos: !byte 0, 48, 50, 52
                             !byte 8, 48, 50, 52
                             !byte 16, 48, 50, 52
                             !byte 24, 48, 50, 52
                             !byte 32, 48, 50, 52
                             !byte 40, 48, 50, 52

EndBorderSpriteSequence:
    ldx .zpSpriteSequenceRestoreStack
    txs
    rts

        
    
!align $FF, $0
; DoBorderStuff: enter @42, exit @25

; UPPER BORDER:
; BorderFade-Char setzen
; Sprites nach vorne holen, Vic-Bank und ram setzen
; LineDelay/LineCrunch
; modus (geht auch über controlV)    
    
; -> 33 takte für DoBorderStuff+rts  17 bis ende rmw, 10 danach+rts    
.DoUpperBorderFade:
    lda .pUpperBorderFade                       ; 4
    bne +                                       ; 2/3
.vUpperBorderStepAfterFade = *+1    
    lda #<.DoUpperBorderLineDelay               ; 2
    sta DoBorderStuffStep                       ; 3
    inc vic_sback                               ; _17   $FF -> $0 Sprites nach vorne!
.vCurrentGfxVicBank = *+1    
    lda #.cVicBorderFadeVicBank                 ; 2    
    sta $dd00                                   ; 4
    nop : nop                                   ; 4    
    rts                                         ; 6   __33   
+   sta .cVic3FFF                               ; 4
    inc .DoUpperBorderFade+1                    ; 6 _17
    lda #0                                      ; 2
    sta zpBorderFinish                          ; 3
    lda #$11                                    ; 2
    sta .zpNextUpperControlV                    ; 3
    rts                                         ; 6   __33   
    

.DoUpperBorderLineDelay:
    lda .zpNextUpperControlV                    ; 3
    and #%11110111                              ; 2
    sta vic_controlv                            ; 4
    adc #1                                      ; 2         ; carry IMMER clear
    dec .vUpperBorderDelayLines                 ; 6 _17
    sta .zpNextUpperControlV                    ; 3
    bne +                                       ; 2/3
.vUpperBorderStepAfterDelay = *+1        
    lda #<.DoUpperBorderLineCrunch              ; 2
    sta  DoBorderStuffStep                      ; 3
    rts                                         ; 6   __33    
+   nop : nop                                   ; 4        
    rts                                         ; 6   __33    


.DoUpperBorderLineCrunch   ; is skipped if no crunch needed
    lda #1                                      ; 2
.vUpperBorderCrunchLines = *+1
    cmp #2                                      ; 2
    lda .zpNextUpperControlV                    ; 3
    and #%11110111                              ; 2   
    bcc +                                       ; 2/3
    inc+2 .zpUnused                             ; 6 _17
    sta vic_controlv                            ; 4
    lda #<.DoUpperBorderIdle                    ; 2
    sta+2 DoBorderStuffStep                     ; 4
    rts                                         ; 6   __33     
+   inc .zpNextUpperControlV                    ; 5 _17
    sta vic_controlv                            ; 4
    dec .vUpperBorderCrunchLines                ; 6
    rts                                         ; 6   __33    
    

.DoUpperBorderIdle:
    lda vic_line                                ; 4       
    cmp #.cFirstGfxLine-1                       ; 2
    bcc +                                       ; 2/3
    lda vic_controlv                            ; 4
    inc zpBorderFinish                          ; 5 _17  
    and #%11110111  ; 24 Rows                   ; 2 
    ora #%00100000  ; BMM=1                     ; 2 
    sta vic_controlv                            ; 4
    nop                                         ; 2
    rts                                         ; 6   __33
+   bne +                                       ; 3    
+   inc .zpUnused                               ; 5 _17  
    inc .zpUnused                               ; 5
    inc .zpUnused                               ; 5
    rts                                         ; 6 __33
    

!if (>.DoUpperBorderFade != >*){
    !error "must be same page for adjustment of .DoBorderStuffStep (and branches): ", .DoUpperBorderFade, " - ", *
}






    
    

!macro NextSpriteIrq .I, .NextFunc{
.IPrev = ((.I+4) % 6)+1
.INext = (.I % 6)+1

    sta zpIrqRestoreA               ; 3     2b ; longer but faster than pha/pla
    stx zpIrqRestoreX               ; 3     2b       _6     _4b

    lda #.INext                     ; 2     2b
    sta zpNextSpriteIndex           ; 3     2b
    lda #<.NextFunc                 ; 2     2b
    sta cpu_irq                     ; 4     3b
    lda #>.NextFunc                 ; 2     2b
    sta cpu_irq+1                   ; 4     3b
    asl vic_irq                     ; 6     3b       _23    _17b ; carry is SET
    
    lda vic_ys0 + (.IPrev*2)        ; 4     3b
    adc #3                          ; 2     2b
    sta vic_ys0 + (.I*2)            ; 4     3b
    adc #1                          ; 2     2b
    sta vic_line                    ; 4     3b       _15    _13b
        
    ldx zpNextSpriteDataOffset      ; 3     2b
    inc zpNextSpriteDataOffset      ; 5     2b
    lda pSpriteX,x                  ; 4     3b
    sta vic_xs0 + (.I*2)            ; 4     3b  ; writes @+54
    lda pSpriteData,x               ; 4     3b
    sta 1016+.I                     ; 4     3b  ; offset HI: 44b
    lda pSpriteColor,x              ; 4     3b
    sta vic_cs0+.I                  ; 4     3b       _32    _22b
    cpx zpNextSpecialSpriteOffset   ; 3     2b
    beq +                           ; 2/3   2b
    
    lda zpIrqRestoreA               ; 3     2b
    ldx zpIrqRestoreX               ; 3     2b
    rti                             ; 6     1b       _12    _5b
                                    ;               __96   
+   jmp ParseSpecialSprite          ;       3b      __86    __63b
}
.cNextSpriteIrqEnterDirectOffset = 4
.cNextSpriteDataPtrOffset = 49
    
; NextSpriteSequence:
.NextSpriteIrq1:
    +NextSpriteIrq 1, .NextSpriteIrq2
.NextSpriteIrq2:
    +NextSpriteIrq 2, .NextSpriteIrq3
.NextSpriteIrq3:
    +NextSpriteIrq 3, .NextSpriteIrq4
.NextSpriteIrq4:
    +NextSpriteIrq 4, .NextSpriteIrq5
.NextSpriteIrq5:
    +NextSpriteIrq 5, .NextSpriteIrq6
.NextSpriteIrq6:
    +NextSpriteIrq 6, .NextSpriteIrq1
    
.NextSpriteDirect1 = .NextSpriteIrq1+.cNextSpriteIrqEnterDirectOffset
.NextSpriteDirect2 = .NextSpriteIrq2+.cNextSpriteIrqEnterDirectOffset
.NextSpriteDirect3 = .NextSpriteIrq3+.cNextSpriteIrqEnterDirectOffset
.NextSpriteDirect4 = .NextSpriteIrq4+.cNextSpriteIrqEnterDirectOffset
.NextSpriteDirect5 = .NextSpriteIrq5+.cNextSpriteIrqEnterDirectOffset
.NextSpriteDirect6 = .NextSpriteIrq6+.cNextSpriteIrqEnterDirectOffset

.pSpriteDataHi_7 = .NextSpriteIrq1+.cNextSpriteDataPtrOffset
.pSpriteDataHi_8 = .NextSpriteIrq2+.cNextSpriteDataPtrOffset
.pSpriteDataHi_9 = .NextSpriteIrq3+.cNextSpriteDataPtrOffset
.pSpriteDataHi_10 = .NextSpriteIrq4+.cNextSpriteDataPtrOffset
.pSpriteDataHi_11 = .NextSpriteIrq5+.cNextSpriteDataPtrOffset
.pSpriteDataHi_12 = .NextSpriteIrq6+.cNextSpriteDataPtrOffset
    
;
; ParseSpecialSprite beginnt 93-100 cycles nach Zeilenstart. In jeder Zeile (ausser bl) sind mindestens 48 Takte verfügbar, also erst rund 2 Zeilen von vier verbraucht
; Special-Sprite Commands: 4-1: logo sprite 0: LineCrunchPtr 
;
ParseSpecialSprite: ;+86
.vSpecialSpriteCommand = *+1
    ldx #4                          ; 2
    beq .LineCrunchSpritePtrLine    ; 2/3       ; nach Logo kommt LinecrunchLine        ->+91
    bpl +                           ; 2/3
    jmp .LastSpriteOnGfxReached     ; 3         ; nach LinecrunchLine kommt ScreenEnd   ->+93
+   lda .pSpecialSpriteNextCmd,x    ; 4
    sta .vSpecialSpriteCommand      ; 4
    lda .pSpecialSpriteNextOff,x    ; 4
    sta zpNextSpecialSpriteOffset   ; 3
    dex                             ; 2
    lda .pNextLogoData0,x           ; 4 _28
.pSpriteDataHi_13 = *+2
    sta 1016                        ; 4
    lda .pNextLogoData7,x           ; 4
.pSpriteDataHi_14 = *+2
    sta 1016 + 7                    ; 4
    lda .pNextLogoY,x               ; 4
    sta vic_ys0                     ; 4
    sta vic_ys7                     ; 4
    lda .pNextLogoColor,x           ; 4
    sta vic_cs0                     ; 4
    sta vic_cs7                     ; 4 _36
    lda zpIrqRestoreA               ; 3
    ldx zpIrqRestoreX               ; 3
    rti                             ; 6  __76 ; noch in der 4. line->irq klappt


; The first 2 Rasterlines are more or less over. use the 3rd to reset the doubleirq for the fourth line.
; The Fourth line is the one BEFORE all 6 Sprites are definitely set, and 2 before the bad line

;; The next "all 6 sprites active"-Line (where the irq is scheduled) is the Line before the SpritePtr-DataLine

.LineCrunchSpritePtrLine: ;+91 ;(.ParseSpecialSprite+5) : minimum 41 cycles until Line reached

    ldx #<.LineCrunchSpritePtrLineIrq   ; 2
    stx cpu_irq                         ; 4
    ldx #>.LineCrunchSpritePtrLineIrq   ; 2
    stx cpu_irq+1                       ; 4 __15

    ;; Nächstes Sprite schonmal vorabeiten... Y ist ja Zeitunkritisch
    lda zpNextSpriteIndex   ; 3
    asl                     ; 2; carry clear
    tax                     ; 2
    lda vic_ys0,x           ; 4
    adc #24                 ; 2
    sta vic_ys0,x           ; 5
    sta vic_line            ; 4 ; 1 Zeile VOR BL
    cpx #2                  ; 2 carry SET bei SpriteIndex=1, Also ist DAVOR #6 dran gewesen, sonst clear
    tsx                     ; 2     _23        __38 (3-16 cycles to new line)   
        
    nop : nop : nop : nop : nop
    nop : nop : nop : nop : nop         ; wait for IRQ. 1 cycle jitter

    
; FOURTH LINE (The one before all 6 Sprites are Set)
.LineCrunchSpritePtrLineIrq: ; enters 7-8 cycles after line start (@16-17). Most Sprites are active, but maybe 6 is missing (@14-15)
    txs                                 ; 2    
   ; carry SET if SpriteIndex was 6! Adjust cycles for missing Sprite#6
    bcc +                               ; 2/3
    bcs +                               ; 3  _5/7       -> @21-22
    
.PrepareEnterSpriteIrq:
    ; NextSpriteIrq vorbereiten                               @32-33
    lda .pNextSpriteEnterHi,y                       ; 4
    pha                                             ; 3
    lda .pNextSpriteEnterLo,y                       ; 4
    pha                                             ; 3
    bcc +                                           ; 3
+   bcc ++                                          ; 3 ->_20 @52-53
 
    ; Es muss noch geprüft werden, ob nach der SpritePtrLine noch ein weiterer SpriteIrq kommt
    ; (dann in den gerade gesetzten Irq+EntryDistance (nach store a,x und setypos) springen)
    ; oder gleich in die LowerBorder gegangen wird (dann StartSpriteYBorderSequence2)
    ; A ist noch die aktuelle VIC-Line
    ; @21-22
+   sty zpIrqRestoreY                               ; 3
    ldy zpNextSpriteIndex                           ; 3
    cmp #.cLastVicLineForContinueWithSpriteIrq      ; 2  
    bcc .PrepareEnterSpriteIrq                      ; 2/3   ; @31-32 / 32-33
    
    ; LowerBorderSequence vorbereiten                         @31-32
    +RtsOnStack .ReturnFromLowerBorderIrq           ;10
    tsx                                             ; 2     
    stx .zpSpriteSequenceRestoreStack               ; 3      
    ldx .pSpriteSequenceStackPos2,y                 ; 4
    txs                                             ; 2 ->_21 @52-53
        
++  dec .vSpecialSpriteCommand                      ; 6       @58-59    can use @57,58 for write
        
    ;@9, no jitter. Next Line is Bad Line. This is line#5
    ; is next line without sprite#1/6? then add 2 cycles
    cpy #1                              ; 2
    bne +                               ; 3/2
    beq +                               ; 3
+   cpy #6                              ; 2
    bne +                               ; 3/2
    beq +                               ; 3    _10     @19 (@21 if Sprite 1 or Sprite 6 will be missing)
+

    lda #>.DoLowerBorderWait            ; 2
    sta DoBorderStuffStep+1             ; 3
    lda #<.DoLowerBorderWait            ; 2
    cpy #.cFirstLowerBorderLine-3 		; 2
    beq +                               ; 3/2
    bne ++                              ; -/3
+   lda #<.DoLowerBorderBlack           ; 2/-
++  sta DoBorderStuffStep               ; 3     _17    @36

    lda .pLastLineWaitCyclesForSprite,y ; 4
    sta .vAdjustSpritePtrLineWaitCycles ; 4            @44
    lda .pSpecialSpriteNextOff          ; 4
    sta zpNextSpecialSpriteOffset       ; 3            @51

!if (>* != >.LineCrunchSpritePtrLineIrq){
    !error "LineCrunchSpritePtrLineIrq: branches may cross page bounds: ", .LineCrunchSpritePtrLineIrq, " - ", * 
}

.vGraphicRamWithSpritePtr = *+1
    lda #0                              ; 2
.vGraphicRamWithoutSpritePtr = *+1
    ldy #0                              ; 2  ; must end @55!
    sty vic_ram                         ; 4          cycles: 55,56,09,10     writes @10
    sta vic_ram                         ; 4          cycles: 11,55,56,57     writes @57 ; still 1 cycle left If Sprite 1 is missing
    
.vAdjustSpritePtrLineWaitCycles:    
    lda #0                              ; 2-4, depending on sprite# -> @11
    
    ldx zpNextSpriteDataOffset          ; 3     
    ldy zpIrqRestoreY                   ; 3
    nop                                 ; 2 _8 -> @19

    ; Enter LowerBorder-Loop OR continue SpriteIrq, depending on Stack
    rts     ; ->@25!                    ; 6
        
.pLastLineWaitCyclesForSprite: !byte 0, opcode_LDA_8, opcode_LDA_IMM, opcode_LDA_IMM, opcode_LDA_IMM, opcode_LDA_IMM, opcode_LDA_8X, 0

    
.LastSpriteOnGfxReached:     ;+89 ;(.ParseSpecialSprite+9) : minimum 43 cycles until Line reached
    sty zpIrqRestoreY                   ; 3
    ldx #<.LastSpriteOnGfxReachedIrq    ; 2
    stx cpu_irq                         ; 4
    ldx #>.LastSpriteOnGfxReachedIrq    ; 2
    stx cpu_irq+1                       ; 4 ->_15 noch 28 cycles
                
    ; LowerBorderSequence vorbereiten                         @31-32
    +RtsOnStack .ReturnFromLowerBorderIrq           ;10
    tsx                                             ; 2
    stx .zpSpriteSequenceRestoreStack               ; 3
    lda .pSpriteSequenceStackPos2,x                 ; 4
    inc vic_line                                    ; 6
    tax                                             ; 2 ->_27 noch 1 cycles
    
    nop : nop : nop : nop : nop
    nop : nop : nop : nop : nop         ; wait for IRQ. 1 cycle jitter

; FOURTH LINE (The one before all 6 Sprites are Set)
.LastSpriteOnGfxReachedIrq: ; enters 7-8 cycles after line start. Most Sprites are active, but maybe 6 is missing
    txs                                 ; 2    
    ldx zpNextSpriteIndex               ; 3
    cpx #1                              ; 2 EQ bei SpriteIndex=1, Also ist DAVOR #6 dran gewesen
    bne +                               ; 3/2
    beq +                               ; 3            @26-27
+    

    lda #>.DoLowerBorderWait            ; 2
    sta DoBorderStuffStep+1             ; 3
    lda #<.DoLowerBorderWait            ; 2
    ldy vic_line                        ; 4
    cpy #.cFirstLowerBorderLine-1       ; 2
    beq +                               ; 3/2
    bne ++                              ; -/3
+   lda #<.DoLowerBorderBlack           ; 2/-
++  sta DoBorderStuffStep               ; 3     _21    @47-48
    nop : nop : nop                     ; 6    @43-44
    inc .zpUnused                       ; 5    @58-59    can use @57,58 for write
 
; FIFTH LINE 
    ;@9, no jitter
    nop : nop : nop : nop : nop ; 10
    rts                         ; 6->@25!        
    
!align $FF, 0    
    
    


; LOWER BORDER:
; warten auf erste schwarz-zeile
; Grafikmodus auf text setzen... color-ram muss komplett schwarz sein!
; sprites nach hinten
; textseite für lower fade einblenden
; open border
; .cVic3FFF setzen   


.DoLowerBorderWait:
    lda #.cFirstLowerBorderLine-1               ; 2
    cmp vic_line                                ; 4
    bne +                                       ; 2/3
    nop                                         ; 2
    lda #$18                                    ; 2
    inc .zpUnused                               ; 5 _17
    sta vic_controlv                            ; 4
    lda #<.DoLowerBorderBlack                   ; 2
    sta+2 DoBorderStuffStep                     ; 4  force 3-byte (non-zeropage) sta
    rts                                         ; 6 __33
+   bne +                                       ; 3
+   inc .zpUnused                               ; 5 _17
    inc .zpUnused                               ; 5
    inc .zpUnused                               ; 5
    rts                                         ; 6 __33
    
.DoLowerBorderBlack:
    lda #<.DoLowerBorderBlack2                  ; 2
    sta DoBorderStuffStep                       ; 3
    lda #.cVicLowerBorderFadeRamPtr             ; 2    
    sta vic_ram                                 ; 4
    dec vic_sback                               ; 6 _17    
    lda #.cVicBorderFadeVicBank                 ; 2    
    sta $dd00                                   ; 4
    nop : nop                                   ; 4
    rts                                         ; 6 __33
 
.DoLowerBorderBlack2:   
    lda #.cOpenBorderLine                       ; 2
    cmp vic_line                                ; 4
    bne +                                       ; 2/3
    nop                                         ; 2
    lda #$10                                    ; 2
    inc .zpUnused                               ; 5 _17
    sta vic_controlv                            ; 4
    lda #<.DoLowerBorderFade                    ; 2
    sta+2 DoBorderStuffStep                     ; 4  force 3-byte (non-zeropage) sta
    rts                                         ; 6 __33
+   bne +                                       ; 3
+   inc .zpUnused                               ; 5 _17
    inc .zpUnused                               ; 5
    inc .zpUnused                               ; 5
    rts                                         ; 6 __33

.DoLowerBorderFade:
    lda .pLowerBorderFade                       ; 4
    cmp #$FF                                    ; 2
    bne +                                       ; 2/3
    nop                                         ; 2
    inc .zpUnused                               ; 5
    sta .cVic3FFF                               ; 4
    lda #<.DoLowerBorderIdle                    ; 2
    sta+2 DoBorderStuffStep                     ; 4  force 3-byte (non-zeropage) sta
    rts                                         ; 6 __33    
+   nop                                         ; 2
    inc .DoLowerBorderFade+1                    ; 6 _17
    sta .cVic3FFF                               ; 4
    nop : nop : nop                             ; 6
    rts                                         ; 6 __33

.DoLowerBorderIdle:
    inc .zpUnused                               ; 5
    inc .zpUnused                               ; 5
    nop                                         ; 2
    inc zpBorderFinish                          ; 5 _17  
    inc .zpUnused                               ; 5
    inc .zpUnused                               ; 5
    rts                                         ; 6 __33    

!if (>.DoLowerBorderWait != >.DoLowerBorderIdle){
    !error "must be same page for adjustment of .DoBorderStuffStep: ", .DoLowerBorderWait, " - ", .DoLowerBorderIdle
}
    
    
.ReturnFromLowerBorderIrq:    
    jsr $1003
    ;prepareNextFrame
    
    jsr .SetupScreenVariables
    lda #<.RasterFirstIRQ           ; 2     2b
    sta cpu_irq                     ; 4     3b
    lda #>.RasterFirstIRQ           ; 2     2b
    sta cpu_irq+1                   ; 4     3b
    asl vic_irq                     ; 6     3b       _23    _17b ; carry is SET
    lda #.cRasterFirstIRQY          ; 2
    sta vic_line                    ; 4
    rti                             ; 6




    
.pSpriteBorderSequenceStackData:
    !byte <(.BorderSpriteSequenceStart1-1),                                >(.BorderSpriteSequenceStart1-1)
    !byte <(.BorderSpriteSequenceStart1+.cSpriteDataSequenceBlock2Off-1),  >(.BorderSpriteSequenceStart1+.cSpriteDataSequenceBlock2Off-1)
    !byte <(.BorderSpriteSequenceStart1+.cSpriteDataSequenceBlock3Off-1),  >(.BorderSpriteSequenceStart1+.cSpriteDataSequenceBlock3Off-1)
    !byte <(.BorderSpriteSequenceStart1+.cSpriteDataSequenceBlock4Off-1),  >(.BorderSpriteSequenceStart1+.cSpriteDataSequenceBlock4Off-1)
    !byte <(.BorderSpriteSequenceStart2-1),                                >(.BorderSpriteSequenceStart2-1)
    !byte <(.BorderSpriteSequenceStart2+.cSpriteDataSequenceBlock2Off-1),  >(.BorderSpriteSequenceStart2+.cSpriteDataSequenceBlock2Off-1)
    !byte <(.BorderSpriteSequenceStart2+.cSpriteDataSequenceBlock3Off-1),  >(.BorderSpriteSequenceStart2+.cSpriteDataSequenceBlock3Off-1)
    !byte <(.BorderSpriteSequenceStart2+.cSpriteDataSequenceBlock4Off-1),  >(.BorderSpriteSequenceStart2+.cSpriteDataSequenceBlock4Off-1)
    !byte <(.BorderSpriteSequenceStart3-1),                                >(.BorderSpriteSequenceStart3-1)
    !byte <(.BorderSpriteSequenceStart3+.cSpriteDataSequenceBlock2Off-1),  >(.BorderSpriteSequenceStart3+.cSpriteDataSequenceBlock2Off-1)
    !byte <(.BorderSpriteSequenceStart3+.cSpriteDataSequenceBlock3Off-1),  >(.BorderSpriteSequenceStart3+.cSpriteDataSequenceBlock3Off-1)
    !byte <(.BorderSpriteSequenceStart3+.cSpriteDataSequenceBlock4Off-1),  >(.BorderSpriteSequenceStart3+.cSpriteDataSequenceBlock4Off-1)
    !byte <(.BorderSpriteSequenceStart4-1),                                >(.BorderSpriteSequenceStart4-1)
    !byte <(.BorderSpriteSequenceStart4+.cSpriteDataSequenceBlock2Off-1),  >(.BorderSpriteSequenceStart4+.cSpriteDataSequenceBlock2Off-1)
    !byte <(.BorderSpriteSequenceStart4+.cSpriteDataSequenceBlock3Off-1),  >(.BorderSpriteSequenceStart4+.cSpriteDataSequenceBlock3Off-1)
    !byte <(.BorderSpriteSequenceStart4+.cSpriteDataSequenceBlock4Off-1),  >(.BorderSpriteSequenceStart4+.cSpriteDataSequenceBlock4Off-1)
    !byte <(.BorderSpriteSequenceStart5-1),                                >(.BorderSpriteSequenceStart5-1)
    !byte <(.BorderSpriteSequenceStart5+.cSpriteDataSequenceBlock2Off-1),  >(.BorderSpriteSequenceStart5+.cSpriteDataSequenceBlock2Off-1)
    !byte <(.BorderSpriteSequenceStart5+.cSpriteDataSequenceBlock3Off-1),  >(.BorderSpriteSequenceStart5+.cSpriteDataSequenceBlock3Off-1)
    !byte <(.BorderSpriteSequenceStart5+.cSpriteDataSequenceBlock4Off-1),  >(.BorderSpriteSequenceStart5+.cSpriteDataSequenceBlock4Off-1)
    !byte <(.BorderSpriteSequenceStart6-1),                                >(.BorderSpriteSequenceStart6-1)
    !byte <(.BorderSpriteSequenceStart6+.cSpriteDataSequenceBlock2Off-1),  >(.BorderSpriteSequenceStart6+.cSpriteDataSequenceBlock2Off-1)
    !byte <(.BorderSpriteSequenceStart6+.cSpriteDataSequenceBlock3Off-1),  >(.BorderSpriteSequenceStart6+.cSpriteDataSequenceBlock3Off-1)
    !byte <(.BorderSpriteSequenceStart6+.cSpriteDataSequenceBlock4Off-1),  >(.BorderSpriteSequenceStart6+.cSpriteDataSequenceBlock4Off-1)
.pSpriteBorderSequenceStackDataEnd:
      
InitializeRasterCode:

;   Legt die rts-Addressen für die SpriteBorderSequence auf den Stack
.InitializeStackForSpriteBorderSequence:
    ldx #(6*4*2)-1
-   lda .pSpriteBorderSequenceStackData,x  
    sta $0101,x
    dex
    bpl -

    lda #<.BorderSpriteSequenceDelay1
    sta $0131
    lda #>.BorderSpriteSequenceDelay1
    sta $0132
    lda #<.BorderSpriteSequenceDelayN
    sta $0133
    sta $0135
    sta $0137
    lda #>.BorderSpriteSequenceDelayN
    sta $0134
    sta $0136
    sta $0138
    
    ldx #0
    txa
-   sta $d800,x
    sta $d900,x
    sta $da00,x
    sta $db00,x
    inx
    bne -
    
    ;ShowAllSprites
    lda #$FF
    sta vic_sactive
    sta vic_sback
    
    ;Set Logo X
    lda #%10000001
    sta vic_msb_xs
    lda #36
    sta vic_xs0
    lda #60
    sta vic_xs7    
    
    lda #0
    sta zpCurrentGfxScrollOffset

    lda #0
    sta zpCurrentSpriteScrollOffset
        
    jsr .SetupScreenVariables
    rts
    
StartRasterIrq:    
	sei
	
	lda #$01
	sta vic_irqmask	; Turn on raster interrupts    	

    lda #<.RasterFirstIRQ           ; 2     2b
    sta cpu_irq                     ; 4     3b
    lda #>.RasterFirstIRQ           ; 2     2b
    sta cpu_irq+1                   ; 4     3b
    asl vic_irq                     ; 6     3b       _23    _17b ; carry is SET
    lda #.cRasterFirstIRQY          ; 2
    sta vic_line                    ; 4
	
	cli
    rts

    

.SetupScreenVariables:    
    lda #<.pUpperBorderFade
    sta .DoUpperBorderFade+1
    lda #<.pLowerBorderFade
    sta .DoLowerBorderFade+1

    ; Setup Sprites 0,7 for Timing
    lda #.cEmptySpriteData
    sta .pVicBorderTextPage+1016    ; 4
    sta .pVicBorderTextPage+1016+7  ; 4
    lda #.cInitialSprite0Y          ; 2
    sta vic_ys0                     ; 4
    lda #.cInitialSprite7Y          ; 2
    sta vic_ys7                     ; 4

    lda #1
    sta .zpFirstVisibleSpriteIndex
    lda #0
    sta .zpFirstVisibleSpriteOffset    
    
    ; Setup Sprites 1-6 : !!TODO!!
    lda #.cRasterFirstIRQY-19       ; 2
    sta vic_ys1                     ; 4
    lda #.cRasterFirstIRQY-15       ; 2
    sta vic_ys2                     ; 4
    lda #.cRasterFirstIRQY-11       ; 2
    sta vic_ys3                     ; 4
    lda #.cRasterFirstIRQY-7        ; 2
    sta vic_ys4                     ; 4
    lda #.cRasterFirstIRQY-3        ; 2
    sta vic_ys5                     ; 4
    lda #.cRasterFirstIRQY+1        ; 2
    sta vic_ys6                     ; 4
    lda #30                         ; 2
    sta vic_xs1                     ; 4
    lda #60                         ; 2
    sta vic_xs2                     ; 4
    lda #90                         ; 2
    sta vic_xs3                     ; 4
    lda #120                        ; 2
    sta vic_xs4                     ; 4
    lda #150                        ; 2
    sta vic_xs5                     ; 4
    lda #180                        ; 2
    sta vic_xs6                     ; 4
    
    lda #1
    sta zpNextSpriteIndex
    
    clc
    lda .zpFirstVisibleSpriteOffset
    adc #6
    sta zpNextSpriteDataOffset

    ; LOGO offsets
    ldx #4    
    stx .vSpecialSpriteCommand    
    clc
    lda .zpFirstVisibleSpriteOffset
    adc #14
    sta zpNextSpecialSpriteOffset
    adc #7
    sta .pSpecialSpriteNextOff+4
    adc #7
    sta .pSpecialSpriteNextOff+3
    adc #7
    sta .pSpecialSpriteNextOff+2    

    lda .zpFirstVisibleSpriteOffset
    adc #.cLastSpriteIrqOffset
    sta .pSpecialSpriteNextOff+1
    sta .pSpecialSpriteNextOff
    lda #-1
    sta .pSpecialSpriteNextCmd+1
    sta .pSpecialSpriteNextCmd
    
    lda #>(pGfxTextPage0 + 1000)
    sta .pSpriteDataHi_1
    sta .pSpriteDataHi_2
    sta .pSpriteDataHi_3
    sta .pSpriteDataHi_4
    sta .pSpriteDataHi_5
    sta .pSpriteDataHi_6
    sta .pSpriteDataHi_7
    sta .pSpriteDataHi_8
    sta .pSpriteDataHi_9
    sta .pSpriteDataHi_10
    sta .pSpriteDataHi_11
    sta .pSpriteDataHi_12
    sta .pSpriteDataHi_13
    sta .pSpriteDataHi_14
    
    ldx zpCurrentGfxScrollOffset    ; 4

    ;; INIT CRUNCH
    lda .pGfxOffsetCrunchLines,x    ; 4
    bne .SetupScreenCrunch        ; 2/3
.SetupScreenNoCrunch:
    lda #<.DoUpperBorderIdle        ; 2
    jmp .SetupScreenCrunchFinal
.SetupScreenCrunch:
    sta .vUpperBorderCrunchLines    ; 4
    lda #<.DoUpperBorderLineCrunch  ; 2    
.SetupScreenCrunchFinal:    
    sta .vUpperBorderStepAfterFade  ; 4
    sta .vUpperBorderStepAfterDelay ; 4

    clc
    lda .pOffsetSpritePtrLine,x
    beq +
    adc .zpFirstVisibleSpriteOffset
    sta .pSpecialSpriteNextOff+1
    lda #0
    sta .pSpecialSpriteNextCmd+1
+
    
    ;; INIT DELAY + CONTROLV
    lda .pGfxOffsetDelayLines,x     ; 4    
    beq .SetupScreenNoDelay         ; 2/3
.SetupScreenDelay:
    sta .vUpperBorderDelayLines     ; 4
    lda #<.DoUpperBorderLineDelay   ; 2
    sta .vUpperBorderStepAfterFade  ; 4
.SetupScreenNoDelay:     
.SetupScreenDelayFinal:
    lda #$10                        ; 2
    sta vic_controlv                ; 4
    adc #1
    sta .zpNextUpperControlV    
    rts
